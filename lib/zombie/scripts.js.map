{"version":3,"sources":["zombie/scripts.js"],"names":[],"mappings":";;;;AAEA,IAAM,GAAG,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;;;;;;AAM7B,IAAI;;AACF,QAAM,YAAY,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AAC9C,OAAG,CAAC,kBAAkB,CAAC,YAAY,GAAG,UAAS,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;AACtE,UAAI,CAAC,UAAU,CAAC,OAAO,EAAE,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC;KAChE,CAAC;;CACH,CAAC,OAAO,KAAK,EAAE,EAEf;;;;;AAKD,GAAG,CAAC,kBAAkB,CAAC,UAAU,GAAG,UAAS,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;;AAEpE,MAAI,CAAC,IAAI,EACP,OAAO;;;AAGT,MAAM,QAAQ,GAAM,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAM,MAAM,GAAQ,QAAQ,CAAC,YAAY,CAAC;AAC1C,MAAM,OAAO,GAAO,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC;AACvC,MAAI,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,EAChC,OAAO;;;AAGT,MAAI;AACF,UAAM,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;GAClC,CAAC,OAAO,KAAK,EAAE;AACd,QAAI,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;AACjC,UAAM,IAAI,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC1D,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AACzB,cAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;KAC7D,MACC,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;GAChE;CACF,CAAC;;;;;;;;;;AAUF,GAAG,CAAC,iBAAiB,CAAC,KAAK,GAAG,YAAW;AACvC,MAAI,CAAC,gBAAgB,CAAC,6BAA6B,EAAE,YAAW;AAC9D,QAAM,MAAM,GAAM,IAAI,CAAC;AACvB,QAAM,QAAQ,GAAI,MAAM,CAAC,aAAa,CAAC;;AAEvC,QAAI,MAAM,CAAC,GAAG,EAAE;;AAEd,SAAG,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;KAC3D,MAAM;;YAGI,mBAAmB;;AAA5B,oBAA+B;AAC7B,gBAAM,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;SAC5C;;AAJD,YAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,QAAO,QAAQ,CAAC,GAAG,UAAK,MAAM,CAAC,EAAE,QAAQ,QAAQ,CAAC,GAAG,YAAS,CAAC,AAIxF,CAAC;;AAEF,YAAM,cAAc,GAAG,GAAG,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,EAAE,mBAAmB,EAAE,QAAQ,CAAC,CAAC;;;;;;;AAOzF,YAAI,QAAQ,CAAC,UAAU,KAAK,SAAS,EACnC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,KAEjC,cAAc,EAAE,CAAC;;KACpB;GACF,CAAC,CAAC;CACJ,CAAC;;;;;;AAMF,GAAG,CAAC,cAAc,CAAC,IAAI,GAAG,UAAS,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;AAC1D,MAAM,QAAQ,GAAQ,OAAO,CAAC,aAAa,CAAC;AAC5C,MAAM,MAAM,GAAU,QAAQ,CAAC,YAAY,CAAC;AAC5C,MAAM,OAAO,GAAS,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;AACpD,MAAM,YAAY,GAAI,QAAQ,CAAC,cAAc,CAAC,WAAW,CAAC,wBAAwB,EAAE,OAAO,CAAC,CAAC;AAC7F,MAAM,GAAG,GAAa,GAAG,CAAC,cAAc,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;;AAEjE,MAAI,YAAY,EAAE;AAChB,QAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;AACnD,UAAM,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,OAAO,CAAC,CAAC;GACnE;;;AAGD,WAAS,MAAM,CAAC,QAAQ,EAAE;AACxB,YAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC;GAChE;CACF,CAAC","file":"zombie/scripts.js","sourcesContent":["// For handling JavaScript, mostly improvements to JSDOM\n\nconst DOM = require('./dom');\n\n\n// -- Patches to JSDOM --\n\n// If you're using CoffeeScript, you get client-side support.\ntry {\n  const CoffeeScript = require('coffee-script');\n  DOM.languageProcessors.coffeescript = function(element, code, filename) {\n    this.javascript(element, CoffeeScript.compile(code), filename);\n  };\n} catch (error) {\n  // Oh, well\n}\n\n\n// If JSDOM encounters a JS error, it fires on the element.  We expect it to be\n// fires on the Window.  We also want better stack traces.\nDOM.languageProcessors.javascript = function(element, code, filename) {\n  // This may be called without code, e.g. script element that has no body yet\n  if (!code)\n    return;\n\n  // Surpress JavaScript validation and execution\n  const document    = element.ownerDocument;\n  const window      = document.parentWindow;\n  const browser     = window.top.browser;\n  if (browser && !browser.runScripts)\n    return;\n\n  // This may be called without code, e.g. script element that has no body yet\n  try {\n    window._evaluate(code, filename);\n  } catch (error) {\n    if (error.hasOwnProperty('stack')) {\n      const cast = new Error(error.message || error.toString());\n      cast.stack = error.stack;\n      document.raise('error', error.message, { exception: cast });\n    } else\n      document.raise('error', error.message, { exception: error });\n  }\n};\n\n\n// HTML5 parser doesn't play well with JSDOM so we need this trickey to sort of\n// get script execution to work properly.\n//\n// Basically JSDOM listend for when the script tag is added to the DOM and\n// attemps to evaluate at, but the script has no contents at that point in\n// time.  This adds just enough delay for the inline script's content to be\n// parsed and ready for processing.\nDOM.HTMLScriptElement._init = function() {\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    const script    = this;\n    const document  = script.ownerDocument;\n\n    if (script.src) {\n      // Script has a src attribute, load external resource.\n      DOM.resourceLoader.load(script, script.src, script._eval);\n    } else {\n      const filename = script.id ?  `${document.URL}:#${script.id}` : `${document.URL}:script`;\n      // Execute inline script\n      function executeInlineScript() {\n        script._eval(script.textContent, filename);\n      };\n      // Queue to be executed in order with all other scripts\n      const executeInOrder = DOM.resourceLoader.enqueue(script, executeInlineScript, filename);\n      // There are two scenarios:\n      // - script element added to existing document, we should evaluate it\n      //   immediately\n      // - inline script element parsed, when we get here, we still don't have\n      //   the element contents, so we have to wait before we can read and\n      //   execute it\n      if (document.readyState === 'loading')\n        process.nextTick(executeInOrder);\n      else\n        executeInOrder();\n    }\n  });\n};\n\n\n// Fix resource loading to keep track of in-progress requests. Need this to wait\n// for all resources (mainly JavaScript) to complete loading before terminating\n// browser.wait.\nDOM.resourceLoader.load = function(element, href, callback) {\n  const document      = element.ownerDocument;\n  const window        = document.parentWindow;\n  const tagName       = element.tagName.toLowerCase();\n  const loadResource  = document.implementation._hasFeature('FetchExternalResources', tagName);\n  const url           = DOM.resourceLoader.resolve(document, href);\n\n  if (loadResource) {\n    const inOrder = this.enqueue(element, loaded, url);\n    window._eventQueue.http('GET', url, { target: element }, inOrder);\n  }\n\n  // This guarantees that all scripts are executed in order\n  function loaded(response) {\n    callback.call(element, response.body.toString(), url.pathname);\n  }\n};\n\n"],"sourceRoot":"/source/"}