{"version":3,"sources":["zombie/eventloop.js"],"names":[],"mappings":"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","file":"zombie/eventloop.js","sourcesContent":["// The event loop.\n//\n// Each browser has an event loop, which processes asynchronous events like\n// loading pages and resources, XHR, timeouts and intervals, etc. These are\n// procesed in order.\n//\n// The purpose of the event loop is two fold:\n// - To get events processed in the right order for the active window (and only\n//   the active window)\n// - And to allow the code to wait until all events have been processed\n//   (browser.wait, .visit, .pressButton, etc)\n//\n// The event loop has one interesting method: `wait`.\n//\n// Each window maintains its own event queue. Its interesting methods are\n// `enqueue`, `http`, `dispatch` and the timeout/interval methods.\n\n\nconst Domain            = require('domain');\nconst { EventEmitter }  = require('events');\nconst ms                = require('ms');\nconst { Promise }       = require('bluebird');\nconst Lazybird          = require('lazybird');\n\n\n// Wrapper for a timeout (setTimeout)\nclass Timeout {\n\n  // queue   - Reference to the event queue\n  // fn      - When timer fires, evaluate this function\n  // delay   - How long to wait\n  // remove  - Call this to discard timer\n  //\n  // Instance variables add:\n  // next    - When is this timer firing next\n  // handle  - Node.js timeout handle\n  constructor(queue, fn, delay, remove) {\n    this.queue  = queue;\n    this.fn     = fn;\n    this.delay  = Math.max(delay || 0, 0);\n    this.remove = remove;\n\n    // When timeout fires, queue event for processing during a wait.\n    const fire = ()=> {\n      this.queue.enqueue(()=> {\n        this.queue.browser.emit('timeout', this.fn, this.delay);\n        try {\n          this.queue.window._evaluate(this.fn);\n        } catch (error) {\n          this.queue.browser.emit('error', error);\n        }\n      });\n      this.remove();\n    };\n    this.handle = global.setTimeout(fire, this.delay);\n    this.next   = Date.now() + this.delay;\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearTimeout(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Wapper for an interval (setInterval)\nclass Interval {\n\n  // queue     - Reference to the event queue\n  // fn        - When timer fires, evaluate this function\n  // interval  - Interval between firing\n  // remove    - Call this to discard timer\n  //\n  // Instance variables add:\n  // next    - When is this timer firing next\n  // handle  - Node.js interval handle\n  constructor(queue, fn, interval, remove) {\n    this.queue    = queue;\n    this.fn       = fn;\n    this.interval =  Math.max(interval || 0);\n    this.remove   = remove;\n\n    // When interval fires, queue event for processing during a wait.\n    // Don't queue if already processing.\n    let pendingEvent = false;\n    const fire = ()=> {\n      this.next = Date.now() + this.interval;\n      if (pendingEvent)\n        return;\n\n      pendingEvent = true;\n      this.queue.enqueue(()=> {\n        pendingEvent = false;\n        this.queue.browser.emit('interval', this.fn, this.interval);\n        try {\n          this.queue.window._evaluate(this.fn);\n        } catch (error) {\n          this.queue.browser.emit('error', error);\n        }\n      });\n    };\n    this.handle = global.setInterval(fire, this.interval);\n    this.next = Date.now() + this.interval;\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearInterval(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Each window has an event queue that holds all pending events and manages\n// timers.\n//\n// Each event is a function that gets called when it's the event time to fire.\n// Various components push new functions to the queue, the event loop is\n// reponsible for fetching the events and executing them.\n//\n// Timers are resumed when the window becomes active, suspened when the window\n// becomes inactive, and execute by queuing events.\n//\n// HTTP request should use the `http` method, which uses `expecting` to indicate\n// an event is expected while the request is in progress (so don't stop event\n// loop), and queue the event when the response arrives.\nclass EventQueue {\n\n  // Instance variables:\n  // browser     - Reference to the browser\n  // window      - Reference to the window\n  // eventLoop   - Reference to the browser's event loop\n  // expecting   - These are holding back the event loop\n  // queue       - FIFO queue of functions to call\n  // timers      - Sparse array of timers (index is the timer handle)\n  // nextTimerHandle - Value of next timer handler\n  constructor(window) {\n    this.window           = window;\n    this.browser          = window.browser;\n    this.eventLoop        = this.browser.eventLoop;\n    this.queue            = [];\n    this.expecting        = [];\n    this.timers           = [];\n    this.eventSources     = [];\n    this.nextTimerHandle  = 1;\n  }\n\n  // Cleanup when we dispose of the window\n  destroy() {\n    this.queue = null;\n    for (let timer of this.timers) {\n      if (timer)\n        timer.stop();\n    }\n    this.timers = null;\n    for (let expecting of this.expecting)\n      expecting();\n    this.expecting = null;\n    for (let eventSource of this.eventSources) {\n      if (eventSource)\n        eventSource.close();\n    }\n    this.eventSources = null;\n  }\n\n\n  // -- Events --\n\n  // Add a function to the event queue, to be executed in order.\n  enqueue(fn) {\n    if (!this.queue)\n      throw new Error('This browser has been destroyed');\n    if (fn) {\n      this.queue.push(fn);\n      this.eventLoop.run();\n    }\n  }\n\n  // Event loop uses this to grab event from top of the queue.\n  dequeue() {\n    if (!this.queue)\n      return;\n    const fn = this.queue.shift();\n    if (fn)\n      return fn;\n    for (let frame of [...this.window.frames]) {\n      let childFn = frame._eventQueue.dequeue();\n      if (childFn)\n        return childFn;\n    }\n    return null;\n  }\n\n  // Makes an HTTP request.\n  //\n  // Parameters are:\n  // method   - Method (defaults to GET)\n  // url      - URL (string)\n  // options  - See below\n  // callback - Called with error, or null and response\n  //\n  // Options:\n  //   headers   - Name/value pairs of headers to send in request\n  //   params    - Parameters to pass in query string or document body\n  //   body      - Request document body\n  //   timeout   - Request timeout in milliseconds (0 or null for no timeout)\n  //\n  // Calls callback with response error or null and response object.\n  http(method, url, options, callback) {\n    if (!this.queue)\n      return;\n\n    const done = this.eventLoop.expecting();\n    this.expecting.push(done);\n\n    this.browser.resources.request(method, url, options, (error, response)=> {\n      // We can't cancel pending requests, but we can ignore the response if\n      // window already closed\n      if (this.queue) {\n\n        // Since this is used by resourceLoader that doesn't check the response,\n        // we're responsible to turn anything other than 2xx/3xx into an error\n        if (response && response.statusCode >= 400)\n          error = new Error(`Server returned status code ${response.statusCode} from ${url}`);\n\n        this.enqueue(()=> {\n          callback(error, response);\n          // Make sure browser gets a hold of this error and adds it to error list\n          // This is necessary since resource loading (CSS, image, etc) does nothing\n          // with the callback error\n          if (error)\n            this.browser.emit('error', error);\n        });\n      }\n\n      if (this.expecting) {\n        this.expecting.splice(this.expecting.indexOf(done), 1);\n        done();\n      }\n    });\n  }\n\n  // Fire an error event.\n  onerror(error) {\n    this.window.console.error(error);\n    this.browser.emit('error', error);\n\n    const event = this.window.document.createEvent('Event');\n    event.initEvent('error', false, false);\n    event.message = error.message;\n    event.error = error;\n    this.window.dispatchEvent(event);\n  }\n\n\n  // -- EventSource --\n\n  addEventSource(eventSource) {\n    if (!this.eventSources)\n      throw new Error('This browser has been destroyed');\n\n    this.eventSources.push(eventSource);\n\n    const emit = eventSource.emit;\n    eventSource.emit = (...args)=> {\n      this.eventLoop.emit('server');\n      this.enqueue(()=> {\n        emit.apply(eventSource, args);\n      });\n    };\n  }\n\n\n  // -- Timers --\n\n  // Window.setTimeout\n  setTimeout(fn, delay = 0) {\n    if (!this.timers)\n      throw new Error('This browser has been destroyed');\n    if (!fn)\n      return;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    const remove = ()=> {\n      delete this.timers[handle];\n    };\n    this.timers[handle] = new Timeout(this, fn, delay, remove);\n    return handle;\n  }\n\n  // Window.clearTimeout\n  clearTimeout(handle) {\n    if (!this.timers)\n      throw new Error('This browser has been destroyed');\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Window.setInterval\n  setInterval(fn, interval = 0) {\n    if (!this.timers)\n      throw new Error('This browser has been destroyed');\n    if (!fn)\n      return;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    const remove = ()=> {\n      delete this.timers[handle];\n    };\n    this.timers[handle] = new Interval(this, fn, interval, remove);\n    return handle;\n  }\n\n  // Window.clearInterval\n  clearInterval(handle) {\n    if (!this.timers)\n      throw new Error('This browser has been destroyed');\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Returns the timestamp of the next timer event\n  next() {\n    let next = Infinity;\n    for (let timer of this.timers) {\n      if (timer && timer.next < next)\n        next = timer.next;\n    }\n    for (let frame of [...this.window.frames]) {\n      let frameNext = frame._eventQueue.next();\n      if (frameNext < next)\n        next = frameNext;\n    }\n    return next;\n  }\n\n}\n\n\n// The browser event loop.\n//\n// All asynchronous events are processed by this one. The event loop monitors one\n// event queue, of the currently active window, and executes its events. Other\n// windows are suspended.\n//\n// Reason to wait for the event loop:\n// - One or more events waiting in the queue to be processed\n// - One or more timers waiting to fire\n// - One or more future events, expected to arrive in the queue\n//\n// Reasons to stop waiting:\n// - No more events in the queue, or expected to arrive\n// - No more timers, or all timers are further than our timeout\n// - Completion function evaluated to true\n//\n// The event loop emits the following events (on the browser):\n// tick  - Emitted after executing an event; single argument is expected time\n//         until next tick event (in ms, zero for \"soon\")\n// done  - Emitted when the event queue is empty (may fire more than once)\n// error - Emitted when an error occurs\nmodule.exports = class EventLoop extends EventEmitter {\n\n  // Instance variables are:\n  // active    - The active window\n  // browser   - Reference to the browser\n  // expected  - Number of events expected to appear (see `expecting` method)\n  // running   - True when inside a run loop\n  // waiting   - Counts calls in-progess calls to wait\n  constructor(browser) {\n    this.browser  = browser;\n    this.active   = null;\n    this.expected = 0;\n    this.running  = false;\n    this.waiting  = 0;\n    // Error in event loop propagates to browser\n    this.on('error', (error)=> {\n      this.browser.emit('error', error);\n    });\n  }\n\n\n  // -- The wait function --\n\n  // Wait until one of these happen:\n  // 1. We run out of events to process; callback is called with null and false\n  // 2. The completion function evaluates to true; callback is called with null\n  //    and false\n  // 3. The time duration elapsed; callback is called with null and true\n  // 2. An error occurs; callback is called with an error\n  //\n  // Duration is specifies in milliseconds or string form (e.g. \"15s\").\n  //\n  // Completion function is called with the currently active window (may change\n  // during page navigation or form submission) and how long until the next\n  // event, and returns true to stop waiting, any other value to continue\n  // processing events.\n  wait(waitDuration, completionFunction) {\n    // Don't wait longer than duration\n    waitDuration = ms(waitDuration.toString()) || this.browser.waitDuration;\n    const timeoutOn = Date.now() + waitDuration;\n\n    const lazy = new Lazybird((resolve)=> {\n      // Someone (us) just started paying attention, start processing events\n      ++this.waiting;\n      if (this.waiting === 1) {\n        setImmediate(()=> {\n          if (this.active)\n            this.run();\n        });\n      }\n\n      let timer   = null;\n      let ontick  = null;\n      let onerror = null;\n      let ondone  = null;\n\n      const work = new Promise((resolve, reject)=> {\n        timer = global.setTimeout(resolve, waitDuration);\n\n        ontick = (next)=> {\n          if (next >= timeoutOn) {\n            // Next event too long in the future, or no events in queue\n            // (Infinity), no point in waiting\n            resolve();\n          } else if (completionFunction && this.active.document.documentElement) {\n            try {\n              const waitFor = Math.max(next - Date.now(), 0);\n              // Event processed, are we ready to complete?\n              const completed = completionFunction(this.active, waitFor);\n              if (completed)\n                resolve();\n            } catch (error) {\n              reject(error);\n            }\n          }\n        };\n        this.on('tick', ontick);\n\n        ondone  = resolve;\n        this.once('done', ondone);\n\n\n        // Don't wait if browser encounters an error (event loop errors also\n        // propagate to browser)\n        onerror = reject;\n        this.browser.once('error', onerror);\n      });\n\n      const finalized = work.finally(()=> {\n        clearInterval(timer);\n        this.removeListener('tick', ontick);\n        this.removeListener('done', ondone);\n        this.browser.removeListener('error', onerror);\n\n        --this.waiting;\n        if (this.waiting === 0)\n          this.browser.emit('done');\n      });\n\n      resolve(finalized);\n    });\n    return lazy;\n  }\n\n\n  dump() {\n    return [];\n  }\n\n  // -- Event queue management --\n\n  // Creates and returns a new event queue (see EventQueue).\n  createEventQueue(window) {\n    return new EventQueue(window);\n  }\n\n  // Set the active window. Suspends processing events from any other window, and\n  // switches to processing events from this window's queue.\n  setActiveWindow(window) {\n    if (window === this.active)\n      return;\n    this.active = window;\n    if (this.active);\n      this.run(); // new window, new events\n  }\n\n  // Call this method when you know an event is coming, but don't have the event\n  // yet. For example, when starting an HTTP request, and the event is for\n  // processing the response.\n  //\n  // This method returns a continuation function that you must call eventually,\n  // of the event loop will wait forever.\n  expecting() {\n    ++this.expected;\n    const done = ()=> {\n      --this.expected;\n      this.run(); // may be dead waiting for next event\n    };\n    return done;\n  }\n\n\n  // Cross-breed between expecting() and process.nextTick.  Executes the function\n  // in the next tick, but makes sure waiters block for the function.\n  next(fn) {\n    ++this.expected;\n    setImmediate(()=> {\n      --this.expected;\n      try {\n        fn();\n        this.run();\n      } catch (error) {\n        this.emit('error', error);\n      }\n    });\n  }\n\n\n  // -- Event processing --\n\n  // Grabs next event from the queue, processes it and notifies all listeners.\n  // Keeps processing until the queue is empty or all listeners are gone. You\n  // only need to bootstrap this when you suspect it's not recursing.\n  run() {\n    // Are we in the midst of another run loop?\n    if (this.running)\n      return;\n    // Is there anybody out there?\n    if (this.waiting === 0)\n      return;\n    // Are there any open windows?\n    if (!this.active) {\n      this.emit('done');\n      return;\n    }\n\n    // Give other (Node) events a chance to process\n    this.running = true;\n    setImmediate(()=> {\n      this.running = false;\n      if (!this.active) {\n        this.emit('done');\n        return;\n      }\n\n      try {\n        const fn = this.active._eventQueue.dequeue();\n        if (fn) {\n          // Process queued function, tick, and on to next event\n          try {\n            fn();\n            this.emit('tick', 0);\n            this.run();\n          } catch (error) {\n            this.emit('error', error);\n          }\n        } else if (this.expected > 0) {\n          // We're waiting for some events to come along, don't know when,\n          // but they'll call run for us\n          this.emit('tick', 0);\n        } else {\n          // All that's left are timers\n          const nextTick = this.active._eventQueue.next();\n          this.emit('tick', nextTick);\n        }\n      } catch (error) {\n        this.emit('error', error);\n      }\n    });\n  }\n\n}\n\n"],"sourceRoot":"/source/"}